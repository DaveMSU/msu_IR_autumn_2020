Примеры запросов (обрати внимание, что наличие или отсутствие пробеллов неважно):
россия
путин & украина
власти & (бельгии | парижа) & !теракт 



Короткое описание, того что реализованно:
  - сжатие Simple9.
  - Бульев поиск, с помощью потокового прохода бинарного дерева.







Подробное описание логики работы программы:

Программу можно эксплуатировать в 2-ух видах

1-ый: запустить Workflow_clear_version.ipynb, в котром реализованна полная логика, описанная ниже
и в очень структурированном удобном для восприятия виде.

2-ой: через терминал командой python3 main.py, подходит для эксплуатации и тестирвоания прогарммы
в целом.

Реалзованная логика:

	(ClearFiles.py)
		В самом начале обрабатываем документы, т.о. получаем с помощью функции
	 clear (в файле ClearFiles.py), получаем 3 словаря:
		- term_to_id:   {termin: term_id} (нумеруем слова, чтобы меньше занимали памяти)
		- url_to_docid: {url: doc_id  (нумеруем урлы по той же причине)
		- docid_to_url: {doc_id: url} (получаем обратный словарь, чтобы было проще по docid в конце
	получать url'ы)
		- reversed_index: {term_id: posting list} (словарь обратных индексов)
	
	
	(Search.py)
		Затем нам поступает бульевский запрос (query), мы парсим его, получаем затем
	список смысловых объектов - знаки операции, скобки, операнды.
		Затем порядок объектов в списке меняется, чтобы формула представляла из
	себя не инфиксную запись, а польскую обратную, т.к. по ней проще построить бинарное
	дерево.
		Таким образом по польской записи строим дерево, где в листьях находятся id терминов,
	через которые мы получаем доступ к постинг листам с помощью словаря reversed_index.
		Дерево обрабатывается потоковым проходом, поддерживаются все операции - &/|/!
		Затем получаем искомое множетсво документов.
		Через словарь docid_to_url получаем искомые урлы.


	(Simple9.py)
		Также реализованно кодирование Simple9 (в файле Simple9.py, в виде класса)
		Идея была следующая - при работе по сети, нам нужен reversed_index, но из-за
	технических ограничений (память/скорость передачи) мы не способны быстро передавать его по сети,
	поэтому, чтобы продемонстировать, что сжатие работает, мы сначала сжимаем reversed_index (как именно
	см. код), переводим из структуры данных "словарь" в обычный массив (подробнее см. код)
	затем расжимаем, возвращаем в прежнюю структуру и удостоверяемся, что не произошло потерь данных.
